<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crane – Core Concept</title><link>/docs/core-concept/</link><description>Recent content in Core Concept on Crane</description><generator>Hugo -- gohugo.io</generator><atom:link href="/docs/core-concept/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Application Resource Optimize Model</title><link>/docs/core-concept/resource-optimize-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/core-concept/resource-optimize-model/</guid><description>
&lt;p>Resource optimization is a common optimization strategy in FinOps. Based on the characteristics of Kubernetes applications, we have summarized the &lt;strong>resource optimization model&lt;/strong> for cloud-native applications:&lt;/p>
&lt;p>&lt;img src="/images/resource-model.png" alt="Resource Model">&lt;/p>
&lt;p>The five lines in the figure from top to bottom are:&lt;/p>
&lt;ol>
&lt;li>Node capacity: the total resources of all nodes in the cluster, corresponding to the Capacity of the cluster&lt;/li>
&lt;li>Allocated: the total resources applied by the application, corresponding to Pod Request&lt;/li>
&lt;li>Weekly peak usage: the peak resource usage of the application in the past period. The weekly peak can predict the resource usage in the future period. Configuring resource specifications based on weekly peak can ensure higher security and stronger versatility.&lt;/li>
&lt;li>Daily peak usage: the peak resource usage of the application in one day&lt;/li>
&lt;li>Average usage: the average resource usage of the application, corresponding to Usage&lt;/li>
&lt;/ol>
&lt;p>There are two types of idle resources:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Resource Slack&lt;/strong>: the difference between Capacity and Request&lt;/li>
&lt;li>&lt;strong>Usage Slack&lt;/strong>: the difference between Request and Usage&lt;/li>
&lt;/ol>
&lt;p>Total Slack = Resource Slack + Usage Slack&lt;/p>
&lt;p>The goal of resource optimization is to reduce Resource Slack and Usage Slack. The model provides four steps for reducing waste, from top to bottom:&lt;/p>
&lt;ol>
&lt;li>Improve packing rate: improving packing rate can make Capacity and Request closer. There are many methods, such as &lt;a href="/docs/tutorials/scheduling-pods-based-on-actual-node-load">dynamic scheduler&lt;/a>, Tencent Cloud native node&amp;rsquo;s node enlargement function, etc.&lt;/li>
&lt;li>Adjust application requests to reduce resource locking: adjust application specifications based on the weekly peak resource usage to reduce Request to the weekly peak line. &lt;a href="/docs/tutorials/recommendation/resource-recommendation">Resource recommendation&lt;/a> and &lt;a href="/docs/tutorials/recommendation/replicas-recommendation">replica recommendation&lt;/a> can help applications achieve this goal.&lt;/li>
&lt;li>Application requests adjustment + scaling to cope with sudden traffic bursts: based on the request optimization, use HPA to cope with sudden traffic bursts, and reduce Request to the daily average peak line. At this time, the target utilization rate of HPA is low, only for coping with sudden traffic, and autoscaling does not occur most of the time. &lt;a href="/docs/tutorials/recommendation/hpa-recommendation">HPA recommendation&lt;/a> can scan out applications suitable for elasticity and provide HPA configuration.&lt;/li>
&lt;li>Application requests adjustment + scaling to cope with daily traffic changes: based on the request optimization, use HPA to cope with daily traffic and reduce Request to the average. At this time, the target utilization rate of HPA is equal to the average utilization rate of the application. &lt;a href="/docs/tutorials/using-effective-hpa-to-scaling-with-effectiveness">EHPA&lt;/a> provide prediction-based horizontal elasticity, helping more applications achieve intelligent elasticity.&lt;/li>
&lt;/ol></description></item><item><title>Docs: Time Series Forecast Algorithm-DSP</title><link>/docs/core-concept/timeseriees-forecasting-by-dsp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/core-concept/timeseriees-forecasting-by-dsp/</guid><description>
&lt;p>时间序列预测是指使用过去的时间序列数据来预测未来的值。时间序列数据通常包括时间和相应的数值，例如资源用量、股票价格或气温。时间序列预测算法 DSP（Digital Signal Processing）是一种数字信号处理技术，可以用于分析和处理时间序列数据。&lt;/p>
&lt;p>离散傅里叶变换（DFT）就是DSP领域常用的一种算法。DFT是一种将时域信号转换为频域信号的技术。通过将时域信号分解成不同的频率成分，可以更好地理解和分析信号的特征和结构。在时间序列预测中，DFT可以用于分析和预测信号的周期性和趋势性，从而提高预测的准确性。&lt;/p>
&lt;p>Crane使用在数字信号处理（Digital Signal Processing）领域中常用的的&lt;code>离散傅里叶变换&lt;/code>、&lt;code>自相关函数&lt;/code>等手段，识别、预测周期性的时间序列。&lt;/p>
&lt;p>本文将介绍DSP算法的实现流程和参数设置，以便帮助大家了解算法背后的原理，并将它应用到实际场景中。 （相关代码位于&lt;code>pkg/prediction/dsp&lt;/code>目录下）&lt;/p>
&lt;h2 id="流程">流程&lt;/h2>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp.png" alt="">&lt;/p>
&lt;h3 id="预处理">预处理&lt;/h3>
&lt;h4 id="填充缺失数据">填充缺失数据&lt;/h4>
&lt;p>监控数据在某些时间点上缺失是很常见的现象，Crane会根据前后的数据对缺失的采样点进行填充。做法如下：&lt;/p>
&lt;p>假设第$m$个与第$n$个采样点之间采样数据缺失（$m+1 &amp;lt; n$）,设在$m$和$n$点的采样值分别为$v_m$和$v_n$，令$$\Delta = {v_n-v_m \over n-m}$$，则$m$和$n$之间的填充数据依次为$v_m+\Delta , v_m+2\Delta , &amp;hellip;$&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/missing_data_fill.png" alt="">&lt;/p>
&lt;h4 id="去除异常点">去除异常点&lt;/h4>
&lt;p>监控数据中偶尔会出现一些极端的异常数据点，导致这些异常点（outliers）的原因有很多，例如：&lt;/p>
&lt;ol>
&lt;li>监控系统用0值填充缺失的采样点；&lt;/li>
&lt;li>被监控组件由于自身的bug上报了错误的指标数据；&lt;/li>
&lt;li>应用启动时会消耗远超正常运行时的资源&lt;/li>
&lt;/ol>
&lt;p>这些极端的异常点对于信号的周期判断会造成干扰，需要进行去除。做法如下：&lt;/p>
&lt;p>选取实际序列中所有采样点的$P99.9$和$P0.1$，分别作为上、下限阈值，如果某个采样值低于下限或者高于上限，将采样点的值设置为前一个采样值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/remove_outliers.png" alt="">&lt;/p>
&lt;h4 id="离散傅里叶变换">离散傅里叶变换&lt;/h4>
&lt;p>对监控的时间序列（设长度为$N$）做快速离散傅里叶变换（FFT），得到信号的频谱图（spectrogram），频谱图直观地表现为在各个离散点$k$处的「冲击」。
冲击的高度为$k$对应周期分量的「幅度」，$k$的取值范围$(0,1,2, &amp;hellip; N-1)$。&lt;/p>
&lt;p>$k = 0$对应信号的「直流分量」，对于周期没有影响，因此忽略。&lt;/p>
&lt;p>由于离散傅里叶变换后的频谱序列前一半和后一半是共轭对称的，反映到频谱图上就是关于轴对称，因此只看前一半$N/2$即可。&lt;/p>
&lt;p>$k$所对应的周期$$T = {N \over k} \bullet SampleInterval$$&lt;/p>
&lt;p>要观察一个信号是不是以$T$为周期，至少需要观察两倍的$T$的长度，因此通过长度为$N$的序列能够识别出的最长周期为$N/2$。所以可以忽略$k = 1$。&lt;/p>
&lt;p>至此，$k$的取值范围为$(2, 3, &amp;hellip; , N/2)$，对应的周期为$N/2, N/3, &amp;hellip;$，这也就是FFT能够提供的周期信息的「分辨率」。如果一个信号的周期没有落到$N/k$上，它会散布到整个频域，导致「频率泄漏」。
好在在实际生产环境中，我们通常遇到的应用（尤其是在线业务），如果有规律，都是以「天」为周期的，某些业务可能会有所谓的「周末」效应，即周末和工作日不太一样，如果扩大到「周」的粒度去观察，它们同样具有良好的周期性。&lt;/p>
&lt;p>Crane没有尝试发现任意长度的周期，而是指定几个固定的周期长度（$1d、7d$）去判断。并通过截取、填充的方式，保证序列的长度$N$为待检测周期$T$的整倍数，例如：$T=1d，N=3d；T=7d，N=14d$。&lt;/p>
&lt;p>我们从生产环境中抓取了一些应用的监控指标，保存为csv格式，放到&lt;code>pkg/prediction/dsp/test_data&lt;/code>目录下。
例如，&lt;code>input0.csv&lt;/code>文件包括了一个应用连续8天的CPU监控数据，对应的时间序列如下图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/input0.png" alt="">&lt;/p>
&lt;p>我们看到，尽管每天的数据不尽相同，但大体「模式」还是基本一致的。&lt;/p>
&lt;p>对它做FFT，会得到下面的频谱图：&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/spectrum.png" alt="">&lt;/p>
&lt;p>我们发现在几个点上的「幅值」明显高于其它点，这些点便可以作为我们的「候选周期」，待进一步的验证。&lt;/p>
&lt;p>上面是我们通过直觉判断的，Crane是如何挑选「候选周期」的呢？&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对原始序列$\vec x(n)$进行一个随机排列后得到序列$\vec x&amp;rsquo;(n)$，再对$\vec x&amp;rsquo;(n)$做FFT得到$\vec X&amp;rsquo;(k)$，令$P_{max} = argmax|\vec X&amp;rsquo;(k)|$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复100次上述操作，得到100个$P_{max}$，取$P99$作为阈值$P_{threshold}$。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对原始序列$\vec x(n)$做FFT得到$\vec X(f)$，遍历$k = 2, 3, &amp;hellip;$，如果$P_k = |X(k)| &amp;gt; P_{threshold}$，则将$k$加入候选周期。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="循环自相关函数">循环自相关函数&lt;/h4>
&lt;p>自相关函数（Auto Correlation Function，ACF）是一个信号于其自身在不同时间点的互相关。通俗的讲，它就是两次观察之间的相似度对它们之间的时间差的函数。&lt;/p>
&lt;p>Crane使用循环自相关函数（Circular ACF），先对长度为$N$的时间序列以$N$为周期做扩展，也就是在$&amp;hellip;, [-N, -1], [N, 2N-1], &amp;hellip;$区间上复制$\vec x(n)$，得到一个新的序列$\vec x&amp;rsquo;(n)$。
再依次计算将$\vec x&amp;rsquo;(n)$依次平移$k=1,2,3,&amp;hellip;N/2$后的$\vec x&amp;rsquo;(n+k)$与$\vec x&amp;rsquo;(n)$的相关系数&lt;/p>
&lt;p>$$r_k={\displaystyle\sum_{i=-k}^{N-k-1} (x_i-\mu)(x_{i+k}-\mu) \over \displaystyle\sum_{i=0}^{N-1} (x_i-\mu)^2}\ \ \ \mu: mean$$&lt;/p>
&lt;p>Crane没有直接使用上面的定义去计算ACF，而是根据下面的公式，通过两次$(I)FFT$，从而能够在$O(nlogn)$的时间内完成ACF的计算。
$$\vec r = IFFT(|FFT({\vec x - \mu \over \sigma})|^2)\ \ \ \mu: mean,\ \sigma: standard\ deviation$$&lt;/p>
&lt;p>ACF的图像如下所示，横轴代表信号平移的时间长度$k$；纵轴代表自相关系数$r_k$，反应了平移信号与原始信号的「相似」程度。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/acf.png" alt="">&lt;/p>
&lt;p>Crane会依次验证每一个候选周期对应的自相关系数是否位于「山顶」上；并且选择对应「最高峰」的那个候选周期为整个时间序列的主周期（基波周期），并以此为基础进行预测。&lt;/p>
&lt;p>如何判断「山顶」？&lt;/p>
&lt;p>Crane在两侧个各选取一段曲线，分别做线性回归，当回归后左、右的直线斜率分别大于、小于零时，则认为这个点是在一个「山顶」上。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/linear_regression.png" alt="">&lt;/p>
&lt;h4 id="预测">预测&lt;/h4>
&lt;p>根据上一步得到的主周期，Crane提供了两种方式去拟合（预测）下一个周期的时序数据
&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>选取过去几个周期中相同时刻$t$（例如：下午6:00）中的最大值，作为下一个周期$t$时刻的预测值。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/max_value.png" alt="">
&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>对原始时间序列做FFT得到频谱序列，去除「高频噪声」后，再做IFFT（逆快速傅里叶变换），将得到的时间序列作为下一个周期的预测结果。&lt;/p>
&lt;h2 id="应用">应用&lt;/h2>
&lt;p>Crane提供了&lt;code>TimeSeriesPrediction&lt;/code>，通过这个CRD，用户可以对各种时间序列进行预测，例如工作负责的CPU利用率、应用的QPS等等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">prediction.crane.io/v1alpha1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">TimeSeriesPrediction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">tsp-workload-dsp&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">spec&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">targetRef&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">apps/v1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">test&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">namespace&lt;/span>: &lt;span style="color:#ae81ff">default&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionWindowSeconds&lt;/span>: &lt;span style="color:#ae81ff">7200&lt;/span> &lt;span style="color:#75715e"># 提供未来7200秒（2小时）的预测数据。Crane会把预测数据写到status中。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">predictionMetrics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">resourceIdentifier&lt;/span>: &lt;span style="color:#ae81ff">workload-cpu&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#ae81ff">ExpressionQuery&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expressionQuery&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">expression&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;sum (irate (container_cpu_usage_seconds_total{container!=&amp;#34;&amp;#34;,image!=&amp;#34;&amp;#34;,container!=&amp;#34;POD&amp;#34;,pod=~&amp;#34;^test-.*$&amp;#34;}[1m]))&amp;#39;&lt;/span> &lt;span style="color:#75715e"># 获取历史监控数据的查询语句&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithm&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">algorithmType&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;dsp&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 指定dsp为预测算法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">dsp&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">sampleInterval&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;60s&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 监控数据的采样间隔为1分钟&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">historyLength&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;15d&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 拉取过去15天的监控指标作为预测的依据&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">estimators&lt;/span>: &lt;span style="color:#75715e"># 指定预测方式，包括&amp;#39;maxValue&amp;#39;和&amp;#39;fft&amp;#39;，每一类可以指定多个estimator，配置不同的参数，crane会选取一个拟合度最高的去产生预测结果。如果不指定的话，默认使用&amp;#39;fft&amp;#39;。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># maxValue:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># - marginFraction: &amp;#34;0.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fft&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">marginFraction&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lowAmplitudeThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;1.0&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">highFrequencyThreshold&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;0.05&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">minNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">maxNumOfSpectrumItems&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面示例中的一些dsp参数含义如下：&lt;/p>
&lt;p>&lt;strong>maxValue&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;strong>fft&lt;/strong>&lt;/p>
&lt;p>&lt;code>marginFraction&lt;/code>: 拟合出下一个周期的序列后，将每一个预测值乘以&lt;code>1 + marginFraction&lt;/code>，例如&lt;code>marginFraction = 0.1&lt;/code>,就是乘以1.1。&lt;code>marginFraction&lt;/code>的作用是将预测数据进行一定比例的放大（或缩小）。&lt;/p>
&lt;p>&lt;code>lowAmplitudeThreshold&lt;/code>: 频谱幅度下限，所有幅度低于这个下限的频率分量将被滤除。&lt;/p>
&lt;p>&lt;code>highFrequencyThreshold&lt;/code>: 频率上限，所有频率高于这个上限的频率分量将被滤除。单位Hz，例如如果想忽略长度小于1小时的周期分量，设置&lt;code>highFrequencyThreshold = 1/3600&lt;/code>。&lt;/p>
&lt;p>&lt;code>minNumOfSpectrumItems&lt;/code>: 至少保留频率分量的个数。&lt;/p>
&lt;p>&lt;code>maxNumOfSpectrumItems&lt;/code>：至多保留频率分量的个数。&lt;/p>
&lt;p>简单来说，保留频率分量的数量越少、频率上限越低、频谱幅度下限越高，预测出来的曲线越光滑，但会丢失一些细节；反之，曲线毛刺越多，保留更多细节。&lt;/p>
&lt;p>下面是对同一时段预测的两条曲线，蓝色、绿色的&lt;code>highFrequencyThreshold&lt;/code>分别为$0.01$和$0.001$，蓝色曲线过滤掉了更多的高频分量，因此更为平滑。&lt;/p>
&lt;p>&lt;img src="/images/algorithm/dsp/lft_0_001.png" alt=""> &lt;img src="/images/algorithm/dsp/lft_0_01.png" alt="">&lt;/p>
&lt;p>并没有一套参数配置适合所有的时间序列，通常需要根据应用指标的特点，去调整算法参数，以期获得最佳的预测效果。
Crane提供了一个web接口，使用者可以在调整参数后，直观的看到预测效果，使用步骤如下：&lt;/p>
&lt;ol>
&lt;li>修改&lt;code>TimeSeriesPrediction&lt;/code>中的&lt;code>estimators&lt;/code>的参数。&lt;/li>
&lt;li>访问craned http server的&lt;code>api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>，查看参数效果（如下图）。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="/images/algorithm/dsp/dsp_debug.png" alt="">&lt;/p>
&lt;p>上述步骤可多次执行，直到得到满意的预测效果。&lt;/p>
&lt;p>&lt;strong>通过port-forward进行本地调试&lt;/strong>&lt;/p>
&lt;p>craned http server的端口通过craned启动参数&lt;code>--server-bind-port&lt;/code>设置，默认为&lt;code>8082&lt;/code>。&lt;/p>
&lt;p>打开终端，&lt;/p>
&lt;pre tabindex="0">&lt;code>$kubectl -n crane-system port-forward service/craned 8082:8082
Forwarding from 127.0.0.1:8082 -&amp;gt; 8082
Forwarding from [::1]:8082 -&amp;gt; 8082
&lt;/code>&lt;/pre>&lt;p>打开浏览器，访问&lt;code>http://localhost:8082/api/prediction/debug/&amp;lt;namespace&amp;gt;/&amp;lt;timeseries prediction name&amp;gt;&lt;/code>&lt;/p></description></item><item><title>Docs: Architecture</title><link>/docs/core-concept/architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/core-concept/architecture/</guid><description>
&lt;p>The overall architecture of Crane is shown as below:&lt;/p>
&lt;p>&lt;img src="/images/crane-arch.png" alt="Crane Arch&amp;quot;">&lt;/p>
&lt;p>&lt;strong>Craned&lt;/strong>&lt;/p>
&lt;p>Craned is the core component which manage the lifecycle of CRDs and APIs. It&amp;rsquo;s deployed by a &lt;code>Deployment&lt;/code> which consists of two container:&lt;/p>
&lt;ul>
&lt;li>Craned: Operators for management CRDs, WebApi for Dashboard, Predictors that provide query TimeSeries API.&lt;/li>
&lt;li>Dashboard: Web component that built from TDesign&amp;rsquo;s Starter, provide an easy-to-use UI for crane users.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Fadvisor&lt;/strong>&lt;/p>
&lt;p>Fadvisor provides a collection of exporters which collect cloud resource pricing and billing data and ship to your monitoring system like Prometheus. Fadvisor support Multi-Cloud Pricing API by &lt;code>Cloud Provider&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Metric Adapter&lt;/strong>&lt;/p>
&lt;p>Metric Adapter implements a &lt;code>Custom Metric Apiserver&lt;/code>. Metric Adapter consume Crane CRDs and provide HPA Metrics by &lt;code>Custom/External Metric API&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Crane Agent&lt;/strong>&lt;/p>
&lt;p>Crane Agent is a &lt;code>DaemonSet&lt;/code> that runs in each node.&lt;/p>
&lt;h2 id="repositories">Repositories&lt;/h2>
&lt;p>Crane is composed of the following components:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/craned">craned&lt;/a> - main crane control plane.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/metric-adapter">metric-adaptor&lt;/a> - Metric server for driving the scaling.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane/tree/main/cmd/crane-agent">crane-agent&lt;/a> - Ensure critical workloads SLO based on abnormally detection.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/api">gocrane/api&lt;/a> - This repository defines component-level APIs for the Crane platform.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/fadvisor">gocrane/fadvisor&lt;/a> - Financial advisor which collect resource prices from cloud API.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/crane-scheduler">gocrane/crane-scheduler&lt;/a> - A Kubernetes scheduler which can schedule pod based on actual node load.&lt;/li>
&lt;li>&lt;a href="https://github.com/gocrane/kubectl-crane">kubectl-crane&lt;/a> - Kubectl plugin for crane, including recommendation and cost estimate.&lt;/li>
&lt;/ul></description></item></channel></rss>